The key contract: If two objects are equal (according to equals()), they must have the same hash code. However, 
two objects with the same hash code don't have to be equal (collision).


Short answer: 31
.31 is small
.odd
.prime
.equals 32 - 1  (gives a good distribution for common inputs)
can be computed quickly as (i << 5) - i

1) Polynomial rolling idea (what 31 actually does)

h = 0;
for each character c:
    h = 31 * h + c;
    
This treats the sequence like a polynomial in base 31:
h = c0*31^(n-1) + c1*31^(n-2) + ... + cn-1


2) Why prime (31) helps

Primes reduce regular patterns: non-prime bases can cause more systematic collisions for some input patterns. Prime bases mix factors less predictably.

31 is small: cheap to compute and keeps values from growing too quickly (but Java allows overflow).

31 is odd: multiplying by an odd number retains more information in low-order bits. Multiplying by an even number repeatedly quickly forces zeros into lower bits.

3) Why 31 = 32 - 1 is an optimization
31 * i == (i << 5) - i because 31 = 2^5 - 1.

i = 123
31 * 123 = 3813
(123 << 5) - 123=(123*32)-123=3936-123=3813
Modern JVMs/JIT often optimize multiplication anyway, but the identity explains why 31 was chosen historically.

abc
'a'=97,
'b'=98,
'c'=99
Compute h with h = 31*h + c
start h=0;
after 'a':h=31*0+97=97;

after 'b':h=31*97+98=3007+98=3105;
       Using shift form 31*97+98 = ((97 << 5) - 97)+98 = (3104 - 97)+98 = 3007+98=3105;
       
After 'c': h = 31*3105 + 99 = 96255 + 99 = 96354
      Or ((3105 << 5) - 3105)+99 = (99360 - 3105)+99 = 96255 then +99 → 96354


abc=inal hash value (before any integer overflow wrapping) is 96354.
In Java int space will wrap if values get large — that’s fine; the wrapping still keeps a distributed result.




Using 31 is a reasonable default — simple, fast, and produces good distributions for many inputs.
Other primes or strategies (e.g., 5381 used in djb2) also work; 
31 is just a pragmatic and widely adopted choice in Java.



x=31 × 7=217

x=(7 << 5) - 7


7 << 5          shift left by 5 bits → same as 7 × 32             224

(7 << 5) - 7    subtract original value                        224 - 7 = 217

31 × 7          normal multiplication                            217

(i << 5) - i works because 31 = 32 - 1.


AB
A=65
B=66

A h = 31×0 + 65=65
B h=31*65+66=2081



APURBA

AUPBRA


//s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
A=65
'a'=97,
B=66
C=67
hash = ( ( (0 * 31 + 65 ) * 31 + 66 ) * 31 + 67 )


Aa       BB
2112    2112


APURBA 
1937389643


h     -> 01110011011110100011100001001011
h>>16 -> 00000000000000000111001101111010             0011100001001011 

XOR
h ^ h>>16

h     -> 01110011011110100011100001001011
h>>16 -> 00000000000000000111001101111010
XOR   -> 01110011011110100100101100110001

1937394481
        

hash & (length - 1);

1937394481 & 15 


1937394481(last 4 bit)->    1110011011110100100101100110001
15                    ->    0000000000000000000000000001111
-----------------------------------------------------------
                            0000000000000000000000000000001
https://www.amazon.in/?&adgr
pid=155259815513&
hvpone=&
hvptwo=&
hvadid=674842289437&
hvpos=&
hvnetw=g&
hvrand=9533703547091745410&
hvqmt=e&
hvdev=c&
hvdvcmdl=&
hvlocint=&
hvlocphy=1007828&
hvtargid=kwd-10573980&hydadcr=14453_2316415












